<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="GB2312-80">
    <title>套接字通信代码</title>
</head>



<body>

<div class="content">
<pre>
import pygame
from pygame.locals import *
import sys
import math

pygame.init()
screen=pygame.display.set_mode((450,550))
pygame.display.set_caption('中国象棋')

img_board = pygame.image.load('board.png')
img_redSoldier = pygame.image.load('redSoldier.png')
img_redCannon = pygame.image.load('redCannon.png')
img_redCa = pygame.image.load('redCar.png')
img_redHorse = pygame.image.load('redHorse.png')
img_redElephant = pygame.image.load('redElephant.png')
img_redAttendant = pygame.image.load('redAttendant.png')
img_chief = pygame.image.load('chief.png')
img_blackSoldier = pygame.image.load('blackSoldier.png')
img_blackCannon = pygame.image.load('blackCannon.png')
img_blackCar = pygame.image.load('blackCar.png')
img_blackHorse = pygame.image.load('blackHorse.png')
img_blackElephant = pygame.image.load('blackElephant.png')
img_blackAttendant = pygame.image.load('blackAttendant.png')
img_general = pygame.image.load('general.png')

screen.blit(img_board,(0,0))
pygame.display.update()

red_chess=[[0,6],[2,6],[4,6],[6,6],[8,6],[1,7],[7,7],[0,9],[1,9],[2,9],[3,9],[4,9],[5,9],[6,9],[7,9],[8,9]]
black_chess=[[0,3],[2,3],[4,3],[6,3],[8,3],[1,2],[7,2],[0,0],[1,0],[2,0],[3,0],[4,0],[5,0],[6,0],[7,0],[8,0]]

#画棋子
def draw_chess():
    for i in range(len(red_chess)):
        if 0<=i<=4:
            screen.blit(img_redSoldier,(red_chess[i][0]*50,red_chess[i][1]*50))
        elif 5<=i<=6:
            screen.blit(img_redCannon,(red_chess[i][0]*50,red_chess[i][1]*50))
        elif i==7 or i==15:
            screen.blit(img_redCa,(red_chess[i][0]*50,red_chess[i][1]*50))
        elif i==8 or i==14:
            screen.blit(img_redHorse,(red_chess[i][0]*50,red_chess[i][1]*50))
        elif i==9 or i==13:
            screen.blit(img_redElephant,(red_chess[i][0]*50,red_chess[i][1]*50))
        elif i==10  or i==12:
            screen.blit(img_redAttendant,(red_chess[i][0]*50,red_chess[i][1]*50))
        else:
            screen.blit(img_chief,(red_chess[i][0]*50,red_chess[i][1]*50))
    for i in range(len(black_chess)):
        if 0<=i<=4:
            screen.blit(img_blackSoldier,(black_chess[i][0]*50,black_chess[i][1]*50))
        elif 5<=i<=6:
            screen.blit(img_blackCannon,(black_chess[i][0]*50,black_chess[i][1]*50))
        elif i==7 or i==15:
            screen.blit(img_blackCar,(black_chess[i][0]*50,black_chess[i][1]*50))
        elif i==8 or i==14:
            screen.blit(img_blackHorse,(black_chess[i][0]*50,black_chess[i][1]*50))
        elif i==9 or i==13:
            screen.blit(img_blackElephant,(black_chess[i][0]*50,black_chess[i][1]*50))
        elif i==10  or i==12:
            screen.blit(img_blackAttendant,(black_chess[i][0]*50,black_chess[i][1]*50))
        else:
            screen.blit(img_general,(black_chess[i][0]*50,black_chess[i][1]*50))
    pygame.display.update()

#返回1表示正常移动，返回2表示有子被吃，返回0表示拒绝移动
#兵移动规则，红兵chess1为red_chess，chess2为black_chess
def soldier_rule(chess1,chess2,current_pos,next_pos):
    if chess1==red_chess:
        pos,index=[5,6],1
    elif chess1==black_chess:
        pos,index=[3,4],-1
    if current_pos[1] in pos:
        if current_pos[0]==next_pos[0] and current_pos[1]==next_pos[1]+index and next_pos not in chess1:
            for i in range(len(chess2)):
                if chess2[i]==next_pos:
                    chess2[i]=[-1,-1]
                    current_pos=next_pos
                    return [current_pos,2]
            current_pos=next_pos
            return [current_pos,1]
    else:
        if current_pos[0]==next_pos[0] and current_pos[1]==next_pos[1]+index and next_pos not in chess1:
            for i in range(len(chess2)):
                if chess2[i]==next_pos:
                    chess2[i]=[-1,-1]
                    current_pos=next_pos
                    return [current_pos,2]
            current_pos=next_pos
            return [current_pos,1]
        elif current_pos[1]==next_pos[1] and current_pos[0]+1==next_pos[0] and next_pos not in chess1:
            for i in range(len(chess2)):
                if chess2[i]==next_pos:
                    chess2[i]=[-1,-1]
                    current_pos=next_pos
                    return [current_pos,2]
            current_pos=next_pos
            return [current_pos,1]
        elif current_pos[1]==next_pos[1] and current_pos[0]-1==next_pos[0] and next_pos not in chess1:
            for i in range(len(chess2)):
                if chess2[i]==next_pos:
                    chess2[i]=[-1,-1]
                    current_pos=next_pos
                    return [current_pos,2]
            current_pos=next_pos
            return [current_pos,1]

#车移动规则，红车前两个参数为red_chess、black_chess，黑车前两个参数为black_chess、red_chess
def car_rule(chess1,chess2,current_pos,next_pos):
    if next_pos not in chess1 and current_pos[0]==next_pos[0]:
        a,b=current_pos,next_pos
        if a[1]>b[1]:
            a,b=b,a
        for i in range(a[1]+1,b[1]):
            if [a[0],i] in black_chess+red_chess:
                return 0
        for i in range(len(chess2)):
            if chess2[i]==next_pos:
                chess2[i]=[-1,-1]
                current_pos=next_pos
                return [current_pos,2]
        current_pos=next_pos
        return [current_pos,1]
    elif next_pos not in chess1 and current_pos[1]==next_pos[1]:
        a,b=current_pos,next_pos
        if a[0]>b[0]:
            a,b=b,a
        for i in range(a[0]+1,b[0]):
            if [i,a[1]] in black_chess+red_chess:
                return 0
        for i in range(len(chess2)):
            if chess2[i]==next_pos:
                chess2[i]=[-1,-1]
                current_pos=next_pos
                return [current_pos,2]
        current_pos=next_pos
        return [current_pos,1]

#炮移动规则
def cannon_rule(chess1,chess2,current_pos,next_pos):
    if next_pos not in chess1 and current_pos[0]==next_pos[0]:
        num=0
        a,b=current_pos,next_pos
        if a[1]>b[1]:
            a,b=b,a
        for i in range(a[1]+1,b[1]):
            if [a[0],i] in black_chess+red_chess:
                num+=1
        if num==1:
            for i in range(len(chess2)):
                if chess2[i]==next_pos:
                    chess2[i]=[-1,-1]
                    current_pos=next_pos
                    return [current_pos,2]
            return 0
        elif num==0:
            current_pos=next_pos
            return [current_pos,1]
        else:
            return 0
    elif next_pos not in chess1 and current_pos[1]==next_pos[1]:
        num=0
        a,b=current_pos,next_pos
        if a[0]>b[0]:
            a,b=b,a
        for i in range(a[0]+1,b[0]):
            if [i,a[1]] in black_chess+red_chess:
                num+=1
        if num==1:
            for i in range(len(chess2)):
                if chess2[i]==next_pos:
                    chess2[i]=[-1,-1]
                    current_pos=next_pos
                    return [current_pos,2]
            return 0
        elif num==0:
            current_pos=next_pos
            return [current_pos,1]
        else:
            return 0

#马移动规则，红马chess为black_chess
def horse_rule(chess,current_pos,next_pos):
    index=[[2,-1],[1,-2],[-1,-2],[-2,-1],[-2,1],[-1,2],[1,2],[2,1]]
    leg=[[1,0],[0,-1],[0,-1],[-1,0],[-1,0],[0,1],[0,1],[1,0]]
    if next_pos not in red_chess+black_chess:
        for i in range(len(index)):
            if current_pos[0]+index[i][0]==next_pos[0] and current_pos[1]+index[i][1]==next_pos[1]:
                if [current_pos[0]+leg[i][0],current_pos[1]+leg[i][1]] not in black_chess+red_chess:
                    current_pos=next_pos
                    return [current_pos,1]
    elif next_pos in chess:
        for i in range(len(index)):
            if current_pos[0]+index[i][0]==next_pos[0] and current_pos[1]+index[i][1]==next_pos[1]:
                if [current_pos[0]+leg[i][0],current_pos[1]+leg[i][1]] not in black_chess+red_chess:
                    for i in range(len(chess)):
                        if chess[i]==next_pos:
                            chess[i]=[-1,-1]
                            current_pos=next_pos
                            return [current_pos,2]

#象移动规则，红相chess为black_chess
def elephant_rule(chess,current_pos,next_pos):
    index=[[2,-2],[-2,-2],[-2,2],[2,2]]
    leg=[[1,-1],[-1,-1],[-1,1],[1,1]]
    if chess==black_chess:
        pos=[5,7,9]
    elif chess==red_chess:
        pos=[0,2,4]
    if next_pos not in red_chess+black_chess and next_pos[1] in pos:
        for i in range(len(index)):
            if current_pos[0]+index[i][0]==next_pos[0] and current_pos[1]+index[i][1]==next_pos[1]:
                if [current_pos[0]+leg[i][0],current_pos[1]+leg[i][1]] not in black_chess+red_chess:
                    current_pos=next_pos
                    return [current_pos,1]
    elif next_pos in chess and next_pos[1] in pos:
        for i in range(len(index)):
            if current_pos[0]+index[i][0]==next_pos[0] and current_pos[1]+index[i][1]==next_pos[1]:
                if [current_pos[0]+leg[i][0],current_pos[1]+leg[i][1]] not in black_chess+red_chess:
                    for i in range(len(chess)):
                        if chess[i]==next_pos:
                            chess[i]=[-1,-1]
                            current_pos=next_pos
                            return [current_pos,2]

#士移动规则
def attendant_rule(chess1,chess2,current_pos,next_pos):
    if chess1==red_chess:
        pos1=[[3,9],[3,7],[5,7],[5,9]]
        pos2=[4,8]
    elif chess1==black_chess:
        pos1=[[3,0],[3,2],[5,2],[5,0]]
        pos2=[4,1]
    if current_pos in pos1 and next_pos==pos2 and next_pos not in chess1:
        if next_pos not in chess2:
            current_pos=next_pos
            return [current_pos,1]
        else:
            for i in range(len(chess2)):
                if chess2[i]==next_pos:
                    chess2[i]=[-1,-1]
                    current_pos=next_pos
                    return [current_pos,2]
    elif current_pos==pos2 and next_pos in pos1 and next_pos not in chess1:
        if next_pos not in chess2:
            current_pos=next_pos
            return [current_pos,1]
        else:
            for i in range(len(chess2)):
                if chess2[i]==next_pos:
                    chess2[i]=[-1,-1]
                    current_pos=next_pos
                    return [current_pos,2]

#将帅移动规则
def boss_rule(chess1,chess2,current_pos,next_pos,j_pos):
    if chess1==red_chess:
        pos=[7,8,9]
    elif chess1==black_chess:
        pos=[0,1,2]
    flag=0
    if next_pos not in chess1:
        if next_pos[0]==j_pos[0]:
            for i in range(j_pos[1]+1,next_pos[1]):
                if [j_pos[0],j_pos[1]+i] in black_chess+red_chess:
                    flag=1
                    break
            if flag==0:
                return 0
    if next_pos not in chess1 and 3<=next_pos[0]<=5 and next_pos[1] in pos:
        if next_pos not in chess2:
            if current_pos[0]==next_pos[0]:
                if current_pos[1]+1==next_pos[1] or current_pos[1]-1==next_pos[1]:
                    current_pos=next_pos
                    return [current_pos,1]
            elif current_pos[1]==next_pos[1]:
                if current_pos[0]+1==next_pos[0] or current_pos[0]-1==next_pos[0]:
                    current_pos=next_pos
                    return [current_pos,1]
        else:
            if current_pos[0]==next_pos[0]:
                if current_pos[1]+1==next_pos[1] or current_pos[1]-1==next_pos[1]:
                    for i in range(len(chess2)):
                        if chess2[i]==next_pos:
                            chess2[i]=[-1,-1]
                            current_pos=next_pos
                            return [current_pos,2]
            elif current_pos[1]==next_pos[1]:
                if current_pos[0]+1==next_pos[0] or current_pos[0]-1==next_pos[0]:
                    for i in range(len(chess2)):
                        if chess2[i]==next_pos:
                            chess2[i]=[-1,-1]
                            current_pos=next_pos
                            return [current_pos,2]

#棋子移动
def move(chess1,chess2,next_pos):
    x=0
    if i in range(5):   #兵
        x=soldier_rule(chess1,chess2,chess1[i],next_pos)
        if x!=None and x!=0:
            chess1[i]=x[0]
            print(chess1[i])
            screen.blit(img_board,(0,0))
            draw_chess()
    elif i==5 or i==6:  #炮
        x=cannon_rule(chess1,chess2,chess1[i],next_pos)
        if x!=None and x!=0:
            chess1[i]=x[0]
            print(chess1[i])
            screen.blit(img_board,(0,0))
            draw_chess()
    elif i==7 or i==15: #車
        x=car_rule(chess1,chess2,chess1[i],next_pos)
        if x!=None and x!=0:
            chess1[i]=x[0]
            print(chess1[i])
            screen.blit(img_board,(0,0))
            draw_chess()
    elif i==8 or i==14: #馬
        x=horse_rule(chess2,chess1[i],next_pos)
        if x!=None and x!=0:
            chess1[i]=x[0]
            print(chess1[i])
            screen.blit(img_board,(0,0))
            draw_chess()
    elif i==9 or i==13: #相
        x=elephant_rule(chess2,chess1[i],next_pos)
        if x!=None and x!=0:
            chess1[i]=x[0]
            print(chess1[i])
            screen.blit(img_board,(0,0))
            draw_chess()
    elif i==10 or i==12:    #仕
        x=attendant_rule(chess1,chess2,chess1[i],next_pos)
        if x!=None and x!=0:
            chess1[i]=x[0]
            print(chess1[i])
            screen.blit(img_board,(0,0))
            draw_chess()
    else:   #帥
        x=boss_rule(chess1,chess2,chess1[i],next_pos,chess2[11])
        if x!=None and x!=0:
            chess1[i]=x[0]
            print(chess1[i])
            screen.blit(img_board,(0,0))
            draw_chess()
    return x

white=(255,255,255)
black=(0,0,0)
def draw_text(text,x,y,size):
    pygame.font.init()
    fontObj=pygame.font.SysFont('SimHei',size )
    textSurfaceObj=fontObj.render(text, True, white,black)
    textRectObj=textSurfaceObj.get_rect()
    textRectObj.center=(x,y)
    screen.blit(textSurfaceObj, textRectObj)
    pygame.display.update()

#判断游戏是否结束
def game_over():
    if red_chess[11]==[-1,-1]:
        draw_text('黑方胜利',225,525,15)
        return 1
    elif black_chess[11]==[-1,-1]:
        draw_text('红方胜利',225,525,15)
        return 1

if __name__=='__main__':
    all_pos,progress=[],[]
    for i in range(10):
        for j in range(9):
            all_pos.append([j,i])
    draw_text('红方先走',225,525,15)
    chess_kind=0
    while True:
        draw_chess()
        for event in pygame.event.get():
            if event.type==QUIT:
                pygame.quit()
                sys.exit()
            elif event.type==MOUSEBUTTONDOWN:
                pos=pygame.mouse.get_pos()
                print(pos)
                if chess_kind==0:
                    chess1,chess2=red_chess,black_chess
                elif chess_kind==1:
                    chess1,chess2=black_chess,red_chess
                for i in range(len(chess1)):
                    if chess1[i][0]*50<pos[0]<(chess1[i][0]+1)*50 and chess1[i][1]*50<pos[1]<(chess1[i][1]+1)*50:
                        flag=False
                        while True:
                            for event in pygame.event.get():
                                if event.type==MOUSEBUTTONDOWN:
                                    pos=pygame.mouse.get_pos()
                                    next_pos=[pos[0]//50,pos[1]//50]
                                    flag=True
                                    break
                            if flag==True:
                                break
                        progress.append(move(chess1,chess2,next_pos))
                        if progress[-1]!=None and progress[-1]!=0:
                            if chess_kind==0:
                                chess_kind=1
                            elif chess_kind==1:
                                chess_kind=0
                        if chess_kind==1:
                            draw_text('轮到黑方',225,525,15)
                        elif chess_kind==0:
                            draw_text('轮到红方',225,525,15)
                        if game_over()==1:
                            while True:
                                for event in pygame.event.get():
                                    if event.type==QUIT:
                                        pygame.quit()
                                        sys.exit()
                        break

</pre>
</div>



</body>
</html>
